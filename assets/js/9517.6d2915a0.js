"use strict";(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[9517],{9517:(e,n,s)=>{s.r(n),s.d(n,{default:()=>t});const t='// <json-manual>\nuse actix_web::{error, post, web, App, Error, HttpResponse};\nuse futures::StreamExt;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Serialize, Deserialize)]\nstruct MyObj {\n    name: String,\n    number: i32,\n}\n\nconst MAX_SIZE: usize = 262_144; // max payload size is 256k\n\n#[post("/")]\nasync fn index_manual(mut payload: web::Payload) -> Result<HttpResponse, Error> {\n    // payload is a stream of Bytes objects\n    let mut body = web::BytesMut::new();\n    while let Some(chunk) = payload.next().await {\n        let chunk = chunk?;\n        // limit max size of in-memory payload\n        if (body.len() + chunk.len()) > MAX_SIZE {\n            return Err(error::ErrorBadRequest("overflow"));\n        }\n        body.extend_from_slice(&chunk);\n    }\n\n    // body is loaded, now we can deserialize serde-json\n    let obj = serde_json::from_slice::<MyObj>(&body)?;\n    Ok(HttpResponse::Ok().json(obj)) // <- send response\n}\n// </json-manual>\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    use actix_web::HttpServer;\n\n    HttpServer::new(|| App::new().service(index_manual))\n        .bind(("127.0.0.1", 8080))?\n        .run()\n        .await\n}\n'}}]);