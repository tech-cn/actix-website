"use strict";(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[2893],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,g=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6931:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={title:"Getting Started",slug:"/actix/getting-started"},o="Getting Started",c={unversionedId:"actix/sec-1-getting-started",id:"actix/sec-1-getting-started",title:"Getting Started",description:"Let\u2019s create and run our first actix application. We\u2019ll create a new Cargo project",source:"@site/docs/actix/sec-1-getting-started.md",sourceDirName:"actix",slug:"/actix/getting-started",permalink:"/actix-website/docs/actix/getting-started",draft:!1,editUrl:"https://github.com/actix/actix-website/edit/master/docs/actix/sec-1-getting-started.md",tags:[],version:"current",frontMatter:{title:"Getting Started",slug:"/actix/getting-started"},sidebar:"docs",previous:{title:"Quick start",permalink:"/actix-website/docs/actix"},next:{title:"Actor",permalink:"/actix-website/docs/actix/actor"}},s={},l=[{value:"Ping actor",id:"ping-actor",level:2}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"getting-started"},"Getting Started"),(0,r.kt)("p",null,"Let\u2019s create and run our first actix application. We\u2019ll create a new Cargo project\nthat depends on actix and then run the application."),(0,r.kt)("p",null,"In previous section we already installed required rust version. Now let's create new cargo projects."),(0,r.kt)("h2",{id:"ping-actor"},"Ping actor"),(0,r.kt)("p",null,"Let\u2019s write our first actix application! Start by creating a new binary-based\nCargo project and changing into the new directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new actor-ping\ncd actor-ping\n")),(0,r.kt)("p",null,"Now, add actix as a dependency of your project by ensuring your Cargo.toml\ncontains the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nactix = "0.11.0"\nactix-rt = "2.2" # <-- Runtime for actix\n')),(0,r.kt)("p",null,"Let's create an actor that will accept a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," message and respond with the number of pings processed."),(0,r.kt)("p",null,"An actor is a type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use actix::prelude::*;\n\nstruct MyActor {\n    count: usize,\n}\n\nimpl Actor for MyActor {\n    type Context = Context<Self>;\n}\n")),(0,r.kt)("p",null,"Each actor has an execution context, for ",(0,r.kt)("inlineCode",{parentName:"p"},"MyActor")," we are going to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Context<A>"),". More information\non actor contexts is available in the next section."),(0,r.kt)("p",null,"Now we need to define the ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," that the actor needs to accept. The message can be any type\nthat implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," trait."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use actix::prelude::*;\n\n#[derive(Message)]\n#[rtype(result = "usize")]\nstruct Ping(usize);\n')),(0,r.kt)("p",null,"The main purpose of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Message")," trait is to define a result type. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," message defines\n",(0,r.kt)("inlineCode",{parentName:"p"},"usize"),", which indicates that any actor that can accept a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," message needs to\nreturn ",(0,r.kt)("inlineCode",{parentName:"p"},"usize")," value."),(0,r.kt)("p",null,"And finally, we need to declare that our actor ",(0,r.kt)("inlineCode",{parentName:"p"},"MyActor")," can accept ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," and handle it.\nTo do this, the actor needs to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Handler<Ping>")," trait."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Handler<Ping> for MyActor {\n    type Result = usize;\n\n    fn handle(&mut self, msg: Ping, _ctx: &mut Context<Self>) -> Self::Result {\n        self.count += msg.0;\n\n        self.count\n    }\n}\n")),(0,r.kt)("p",null,"That's it. Now we just need to start our actor and send a message to it.\nThe start procedure depends on the actor's context implementation. In our case we can use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Context<A>")," which is tokio/future based. We can start it with ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor::start()"),"\nor ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor::create()"),". The first is used when the actor instance can be created immediately.\nThe second method is used in case we need access to the context object before we can create\nthe actor instance. In case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"MyActor")," actor we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"start()"),"."),(0,r.kt)("p",null,"All communication with actors goes through an address. You can ",(0,r.kt)("inlineCode",{parentName:"p"},"do_send")," a message\nwithout waiting for a response, or ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," to an actor with a specific message.\nBoth ",(0,r.kt)("inlineCode",{parentName:"p"},"start()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"create()")," return an address object."),(0,r.kt)("p",null,"In the following example we are going to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"MyActor")," actor and send one message."),(0,r.kt)("p",null,"Here we use the actix-rt as way to start our System and drive our main Future\nso we can easily ",(0,r.kt)("inlineCode",{parentName:"p"},".await")," for the messages sent to the Actor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[actix_rt::main] \nasync fn main() {\n    // start new actor\n    let addr = MyActor { count: 10 }.start();\n\n    // send message and get future for result\n    let res = addr.send(Ping(10)).await;\n\n    // handle() returns tokio handle\n    println!("RESULT: {}", res.unwrap() == 20);\n\n    // stop system and exit\n    System::current().stop();\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"#[actix_rt::main]")," starts the system and block until future resolves."),(0,r.kt)("p",null,"The Ping example is available in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/actix/actix/tree/master/actix/examples/"},"examples directory"),"."))}d.isMDXComponent=!0}}]);