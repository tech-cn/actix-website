"use strict";(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[926],{926:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});const s='// <stream-response>\nuse std::task::Poll;\n\nuse actix_web::{\n    http::{self, header::ContentEncoding, StatusCode},\n    web, App, Error, HttpRequest, HttpResponse,\n};\nuse futures::stream;\n\nasync fn sse(_req: HttpRequest) -> HttpResponse {\n    let mut counter: usize = 5;\n\n    // yields `data: N` where N in [5; 1]\n    let server_events =\n        stream::poll_fn(move |_cx| -> Poll<Option<Result<web::Bytes, Error>>> {\n            if counter == 0 {\n                return Poll::Ready(None);\n            }\n            let payload = format!("data: {}\\n\\n", counter);\n            counter -= 1;\n            Poll::Ready(Some(Ok(web::Bytes::from(payload))))\n        });\n\n    HttpResponse::build(StatusCode::OK)\n        .insert_header((http::header::CONTENT_TYPE, "text/event-stream"))\n        .insert_header(ContentEncoding::Identity)\n        .streaming(server_events)\n}\n\npub fn main() {\n    App::new().route("/", web::get().to(sse));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use actix_web::{body, body::MessageBody as _, rt::pin, test, web, App};\n    use futures::future;\n\n    #[actix_web::test]\n    async fn test_stream_chunk() {\n        let app = test::init_service(App::new().route("/", web::get().to(sse))).await;\n        let req = test::TestRequest::get().to_request();\n\n        let resp = test::call_service(&app, req).await;\n        assert!(resp.status().is_success());\n\n        let body = resp.into_body();\n        pin!(body);\n\n        // first chunk\n        let bytes = future::poll_fn(|cx| body.as_mut().poll_next(cx)).await;\n        assert_eq!(\n            bytes.unwrap().unwrap(),\n            web::Bytes::from_static(b"data: 5\\n\\n")\n        );\n\n        // second chunk\n        let bytes = future::poll_fn(|cx| body.as_mut().poll_next(cx)).await;\n        assert_eq!(\n            bytes.unwrap().unwrap(),\n            web::Bytes::from_static(b"data: 4\\n\\n")\n        );\n\n        // remaining part\n        for i in 0..3 {\n            let expected_data = format!("data: {}\\n\\n", 3 - i);\n            let bytes = future::poll_fn(|cx| body.as_mut().poll_next(cx)).await;\n            assert_eq!(bytes.unwrap().unwrap(), web::Bytes::from(expected_data));\n        }\n    }\n\n    #[actix_web::test]\n    async fn test_stream_full_payload() {\n        let app = test::init_service(App::new().route("/", web::get().to(sse))).await;\n        let req = test::TestRequest::get().to_request();\n\n        let resp = test::call_service(&app, req).await;\n        assert!(resp.status().is_success());\n\n        let body = resp.into_body();\n        let bytes = body::to_bytes(body).await;\n        assert_eq!(\n            bytes.unwrap(),\n            web::Bytes::from_static(b"data: 5\\n\\ndata: 4\\n\\ndata: 3\\n\\ndata: 2\\n\\ndata: 1\\n\\n")\n        );\n    }\n}\n// </stream-response>\n'}}]);