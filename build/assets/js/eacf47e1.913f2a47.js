"use strict";(self.webpackChunkactix_website=self.webpackChunkactix_website||[]).push([[2221],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2214:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={title:"Actor",slug:"/actix/actor"},s="Actor",i={unversionedId:"actix/sec-2-actor",id:"actix/sec-2-actor",title:"Actor",description:"Actix is a rust library providing a framework for developing concurrent applications.",source:"@site/docs/actix/sec-2-actor.md",sourceDirName:"actix",slug:"/actix/actor",permalink:"/docs/actix/actor",draft:!1,editUrl:"https://github.com/actix/actix-website/edit/master/docs/actix/sec-2-actor.md",tags:[],version:"current",frontMatter:{title:"Actor",slug:"/actix/actor"},sidebar:"docs",previous:{title:"Getting Started",permalink:"/docs/actix/getting-started"},next:{title:"Address",permalink:"/docs/actix/address"}},l={},c=[{value:"Actor lifecycle",id:"actor-lifecycle",level:2},{value:"Started",id:"started",level:3},{value:"Running",id:"running",level:3},{value:"Stopping",id:"stopping",level:3},{value:"Stopped",id:"stopped",level:3},{value:"Message",id:"message",level:2},{value:"Spawning an actor",id:"spawning-an-actor",level:2},{value:"Complete example",id:"complete-example",level:2},{value:"Responding with a MessageResponse",id:"responding-with-a-messageresponse",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"actor"},"Actor"),(0,r.kt)("p",null,"Actix is a rust library providing a framework for developing concurrent applications."),(0,r.kt)("p",null,"Actix is built on the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Actor_model"},"Actor Model"),' which\nallows applications to be written as a group of independently executing but cooperating\n"Actors" which communicate via messages. Actors are objects which encapsulate\nstate and behavior and run within the ',(0,r.kt)("em",{parentName:"p"},"Actor System")," provided by the actix library."),(0,r.kt)("p",null,"Actors run within a specific execution context ",(0,r.kt)("a",{parentName:"p",href:"./context"},(0,r.kt)("inlineCode",{parentName:"a"},"Context<A>")),".\nThe context object is available only during execution. Each actor has a separate\nexecution context. The execution context also controls the lifecycle of an actor."),(0,r.kt)("p",null,"Actors communicate exclusively by exchanging messages. The sending actor can\noptionally wait for the response. Actors are not referenced directly, but by means\nof addresses."),(0,r.kt)("p",null,"Any rust type can be an actor, it only needs to implement the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/actix/latest/actix/trait.Actor.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Actor"))," trait."),(0,r.kt)("p",null,"To be able to handle a specific message the actor has to provide a\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/actix/latest/actix/trait.Handler.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Handler<M>"))," implementation for this message. All messages\nare statically typed. The message can be handled in an asynchronous fashion.\nActor can spawn other actors or add futures or streams to execution context.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," trait provides several methods that allow controlling the actor's lifecycle."),(0,r.kt)("h2",{id:"actor-lifecycle"},"Actor lifecycle"),(0,r.kt)("h3",{id:"started"},"Started"),(0,r.kt)("p",null,"An actor always starts in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Started")," state. During this state the actor's ",(0,r.kt)("inlineCode",{parentName:"p"},"started()"),"\nmethod is called. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," trait provides a default implementation for this method.\nThe actor context is available during this state and the actor can start more actors or register\nasync streams or do any other required configuration."),(0,r.kt)("h3",{id:"running"},"Running"),(0,r.kt)("p",null,"After an Actor's ",(0,r.kt)("inlineCode",{parentName:"p"},"started()")," method is called, the actor transitions to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Running")," state.\nThe Actor can stay in ",(0,r.kt)("inlineCode",{parentName:"p"},"running")," state indefinitely."),(0,r.kt)("h3",{id:"stopping"},"Stopping"),(0,r.kt)("p",null,"The Actor's execution state changes to the ",(0,r.kt)("inlineCode",{parentName:"p"},"stopping")," state in the following situations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Context::stop")," is called by the actor itself"),(0,r.kt)("li",{parentName:"ul"},"all addresses to the actor get dropped. i.e. no other actor references it."),(0,r.kt)("li",{parentName:"ul"},"no event objects are registered in the context.")),(0,r.kt)("p",null,"An actor can restore from the ",(0,r.kt)("inlineCode",{parentName:"p"},"stopping")," state to the ",(0,r.kt)("inlineCode",{parentName:"p"},"running")," state by creating a new\naddress or adding an event object, and by returning ",(0,r.kt)("inlineCode",{parentName:"p"},"Running::Continue"),"."),(0,r.kt)("p",null,"If an actor changed state to ",(0,r.kt)("inlineCode",{parentName:"p"},"stopping")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"Context::stop()")," is called\nthen the context immediately stops processing incoming messages and calls\n",(0,r.kt)("inlineCode",{parentName:"p"},"Actor::stopping()"),". If the actor does not restore back to the ",(0,r.kt)("inlineCode",{parentName:"p"},"running")," state, all\nunprocessed messages are dropped."),(0,r.kt)("p",null,"By default this method returns ",(0,r.kt)("inlineCode",{parentName:"p"},"Running::Stop")," which confirms the stop operation."),(0,r.kt)("h3",{id:"stopped"},"Stopped"),(0,r.kt)("p",null,"If the actor does not modify the execution context during the stopping state, the actor state changes\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"Stopped"),". This state is considered final and at this point the actor is dropped."),(0,r.kt)("h2",{id:"message"},"Message"),(0,r.kt)("p",null,"An Actor communicates with other actors by sending messages. In actix all\nmessages are typed. A message can be any rust type which implements the\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/actix/latest/actix/trait.Message.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Message"))," trait. ",(0,r.kt)("inlineCode",{parentName:"p"},"Message::Result")," defines the return type.\nLet's define a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," message - an actor which will accept this message needs to return\n",(0,r.kt)("inlineCode",{parentName:"p"},"Result<bool, std::io::Error>"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use actix::prelude::*;\n\nstruct Ping;\n\nimpl Message for Ping {\n    type Result = Result<bool, std::io::Error>;\n}\n")),(0,r.kt)("h2",{id:"spawning-an-actor"},"Spawning an actor"),(0,r.kt)("p",null,"How to start an actor depends on its context. Spawning a new async actor\nis achieved via the ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," methods of\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/actix/latest/actix/trait.Actor.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Actor"))," trait. It provides several different ways of\ncreating actors; for details check the docs."),(0,r.kt)("h2",{id:"complete-example"},"Complete example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use actix::prelude::*;\n\n/// Define message\n#[derive(Message)]\n#[rtype(result = "Result<bool, std::io::Error>")]\nstruct Ping;\n\n// Define actor\nstruct MyActor;\n\n// Provide Actor implementation for our actor\nimpl Actor for MyActor {\n    type Context = Context<Self>;\n\n    fn started(&mut self, ctx: &mut Context<Self>) {\n       println!("Actor is alive");\n    }\n\n    fn stopped(&mut self, ctx: &mut Context<Self>) {\n       println!("Actor is stopped");\n    }\n}\n\n/// Define handler for `Ping` message\nimpl Handler<Ping> for MyActor {\n    type Result = Result<bool, std::io::Error>;\n\n    fn handle(&mut self, msg: Ping, ctx: &mut Context<Self>) -> Self::Result {\n        println!("Ping received");\n\n        Ok(true)\n    }\n}\n\n#[actix_rt::main]\nasync fn main() {\n    // Start MyActor in current thread\n    let addr = MyActor.start();\n\n    // Send Ping message.\n    // send() message returns Future object, that resolves to message result\n    let result = addr.send(Ping).await;\n\n    match result {\n        Ok(res) => println!("Got result: {}", res.unwrap()),\n        Err(err) => println!("Got error: {}", err),\n    }\n}\n')),(0,r.kt)("h2",{id:"responding-with-a-messageresponse"},"Responding with a MessageResponse"),(0,r.kt)("p",null,"Let's take a look at the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," type defined for the ",(0,r.kt)("inlineCode",{parentName:"p"},"impl Handler")," in the above example.\nSee how we're returning a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<bool, std::io::Error>"),"? We're able to respond to our actor's\nincoming message with this type because it has the ",(0,r.kt)("inlineCode",{parentName:"p"},"MessageResponse")," trait implemented for that type.\nHere's the definition for that trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait MessageResponse<A: Actor, M: Message> {\n    fn handle(self, ctx: &mut A::Context, tx: Option<OneshotSender<M::Result>>);\n}\n")),(0,r.kt)("p",null,"Sometimes it makes sense to respond to incoming messages with types that don't have this trait\nimplemented for them. When that happens we can implement the trait ourselves.\nHere's an example where we're responding to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ping")," message with a ",(0,r.kt)("inlineCode",{parentName:"p"},"GotPing"),",\nand responding with ",(0,r.kt)("inlineCode",{parentName:"p"},"GotPong")," for a ",(0,r.kt)("inlineCode",{parentName:"p"},"Pong")," message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use actix::dev::{MessageResponse, OneshotSender};\nuse actix::prelude::*;\n\n#[derive(Message)]\n#[rtype(result = "Responses")]\nenum Messages {\n    Ping,\n    Pong,\n}\n\nenum Responses {\n    GotPing,\n    GotPong,\n}\n\nimpl<A, M> MessageResponse<A, M> for Responses\nwhere\n    A: Actor,\n    M: Message<Result = Responses>,\n{\n    fn handle(self, ctx: &mut A::Context, tx: Option<OneshotSender<M::Result>>) {\n        if let Some(tx) = tx {\n            tx.send(self);\n        }\n    }\n}\n\n// Define actor\nstruct MyActor;\n\n// Provide Actor implementation for our actor\nimpl Actor for MyActor {\n    type Context = Context<Self>;\n\n    fn started(&mut self, _ctx: &mut Context<Self>) {\n        println!("Actor is alive");\n    }\n\n    fn stopped(&mut self, _ctx: &mut Context<Self>) {\n        println!("Actor is stopped");\n    }\n}\n\n/// Define handler for `Messages` enum\nimpl Handler<Messages> for MyActor {\n    type Result = Responses;\n\n    fn handle(&mut self, msg: Messages, _ctx: &mut Context<Self>) -> Self::Result {\n        match msg {\n            Messages::Ping => Responses::GotPing,\n            Messages::Pong => Responses::GotPong,\n        }\n    }\n}\n\n#[actix_rt::main]\nasync fn main() {\n    // Start MyActor in current thread\n    let addr = MyActor.start();\n\n    // Send Ping message.\n    // send() message returns Future object, that resolves to message result\n    let ping_future = addr.send(Messages::Ping).await;\n    let pong_future = addr.send(Messages::Pong).await;\n\n    match pong_future {\n        Ok(res) => match res {\n            Responses::GotPing => println!("Ping received"),\n            Responses::GotPong => println!("Pong received"),\n        },\n        Err(e) => println!("Actor is probably dead: {}", e),\n    }\n\n    match ping_future {\n        Ok(res) => match res {\n            Responses::GotPing => println!("Ping received"),\n            Responses::GotPong => println!("Pong received"),\n        },\n        Err(e) => println!("Actor is probably dead: {}", e),\n    }\n}\n')))}d.isMDXComponent=!0}}]);